# -*- coding: utf-8 -*-
"""my_fastapi_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vw2j2Zlv2jdXXcqzCLy7oDm4oX4qJq0T

# 1. Data Structure for AST
We  use a basic node structure where each node in the AST can be an operator (AND/OR) or an operand (conditions like age, department, etc.).
"""

!pip install pyparsing
class Node:
    def __init__(self, type, value=None, left=None, right=None):
        self.type = type  # 'operator' for AND/OR, 'operand' for conditions
        self.value = value  # Optional for operator, needed for operands
        self.left = left  # Left child (used for operators)
        self.right = right  # Right child (used for operators)

    def __repr__(self):
        return f"Node(type={self.type}, value={self.value})"

        # 2. Rule Parsing (AST Creation)
#We  use pyparsing to define the grammar for rules and parse them into an AST. Let's start by parsing simple expressions like age > 30.


from pyparsing import Word, alphas, nums, oneOf, quotedString, infixNotation, opAssoc, removeQuotes, Group

def parse_rule(rule_string):
    # Define grammar for variables and constants
    variable = Word(alphas)
    integer = Word(nums)
    comparison_op = oneOf("> < >= <= =")  # Define valid comparison operators
    quoted_string = quotedString.setParseAction(removeQuotes)  # Handle quoted strings like 'Sales'

    # Define a condition like 'age > 30' or 'department = 'Sales''
    condition = Group(variable + comparison_op + (integer | quoted_string))

    # Define operators AND/OR with precedence
    expr = infixNotation(condition, [
        ("AND", 2, opAssoc.LEFT),
        ("OR", 2, opAssoc.LEFT)
    ])

    # Parse the rule string
    parsed = expr.parseString(rule_string)
    return parsed[0]

# Test rule parsing
rule_string = "((age > 30 AND department = 'Sales') OR (age < 25 AND department = 'Marketing')) AND salary > 50000"
parsed_rule = parse_rule(rule_string)
print(parsed_rule)
# 3. Convert Parsed Rule to AST
#Once we parse the rule string, we need to convert it into an AST using the Node class.
def create_ast(parsed_expr):
    if isinstance(parsed_expr, list):
        if len(parsed_expr) == 3 and parsed_expr[1] in ("AND", "OR"):
            return Node(
                type="operator",
                value=parsed_expr[1],
                left=create_ast(parsed_expr[0]),
                right=create_ast(parsed_expr[2])
            )
        else:
            return Node(type="operand", value={"var": parsed_expr[0], "op": parsed_expr[1], "val": parsed_expr[2]})
    else:
        return Node(type="operand", value=parsed_expr)

# Create AST from parsed rule
ast_root = create_ast(parsed_rule)
print(ast_root)
# 4. API Design (Using FastAPI)
#Install FastAPI and Uvicorn to run the API server:
!pip install fastapi uvicorn

#Create the FastAPI app:

#Test Cases:
#1. Create individual rules from the examples using create_rule and verify their AST
#2. Combine the example rules using combine_rules and ensure the resulting AST
#reflects the combined logic.
#3. Implement sample JSON data and test evaluate_rule for different scenarios.
#4. Explore combining additional rules and test the functionality.

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Dict

app = FastAPI()

class RuleRequest(BaseModel):
    rule: str

class EvaluateRequest(BaseModel):
    ast: Dict
    data: Dict

# In-memory store for rules
rules_store = []

@app.post("/create_rule/")
def create_rule(rule_req: RuleRequest):
    try:
        parsed_rule = parse_rule(rule_req.rule)
        ast_root = create_ast(parsed_rule)
        rule_id = len(rules_store)
        rules_store.append(ast_root)
        return {"rule_id": rule_id, "ast": ast_root}
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid rule format: {str(e)}")

@app.post("/combine_rules/")
def combine_rules(rule_ids: List[int]):
    try:
        if len(rule_ids) < 2:
            raise HTTPException(status_code=400, detail="At least two rules required for combination")

        combined_ast = Node(type="operator", value="AND", left=rules_store[rule_ids[0]], right=rules_store[rule_ids[1]])
        for rule_id in rule_ids[2:]:
            combined_ast = Node(type="operator", value="AND", left=combined_ast, right=rules_store[rule_id])

        combined_rule_id = len(rules_store)
        rules_store.append(combined_ast)
        return {"combined_rule_id": combined_rule_id, "ast": combined_ast}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/evaluate_rule/")
def evaluate_rule(eval_req: EvaluateRequest):
    def evaluate_node(node, data):
        if node.type == "operand":
            var = node.value["var"]
            op = node.value["op"]
            val = int(node.value["val"]) if node.value["val"].isdigit() else node.value["val"].strip("'")
            user_val = data[var]

            # Simple comparison
            if op == ">":
                return user_val > val
            elif op == "<":
                return user_val < val
            elif op == "=":
                return user_val == val
            elif op == ">=":
                return user_val >= val
            elif op == "<=":
                return user_val <= val

        elif node.type == "operator":
            if node.value == "AND":
                return evaluate_node(node.left, data) and evaluate_node(node.right, data)
            elif node.value == "OR":
                return evaluate_node(node.left, data) or evaluate_node(node.right, data)

    try:
        result = evaluate_node(eval_req.ast, eval_req.data)
        return {"result": result}
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Evaluation failed: {str(e)}")

# 5. Running the Application
#Start the FastAPI server:

from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello from Google Colab!"}
!pip install pyngrok
!pip install fastapi uvicorn pyngrok

# Install required packages
!pip install fastapi uvicorn pyngrok

# Import necessary libraries
import nest_asyncio
import uvicorn
from pyngrok import ngrok

# Authenticate ngrok (replace with your actual authtoken)
ngrok.set_auth_token("2nc3G6sW9vH6zNNYQUQ4IlRf7W2_6nZ3iwwgibC9zLU9t9WwE")  # Use quotes around the token

# Allow nested asynchronous calls
nest_asyncio.apply()

# Create FastAPI app
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello from Google Colab!"}

# Run the FastAPI app
public_url = ngrok.connect(8000)
print("Public URL:", public_url)

# Start the Uvicorn server
uvicorn.run(app, host="0.0.0.0", port=8000)

# test_my_fastapi_app.py
import pytest
from fastapi.testclient import TestClient
from my_fastapi_app import app  # Ensure the app is imported correctly

client = TestClient(app)

def test_create_rule():
    response = client.post("/create_rule/", json={"rule": "age > 30"})
    assert response.status_code == 200
    assert "rule_id" in response.json()

def test_evaluate_rule():
    rule_response = client.post("/create_rule/", json={"rule": "age > 30"})
    rule_id = rule_response.json()["rule_id"]

    eval_response = client.post("/evaluate_rule/", json={
        "ast": rule_response.json()["ast"],
        "data": {"age": 31}
    })
    assert eval_response.status_code == 200
    assert eval_response.json()["result"] is True

!pytest -v test_my_fastapi_app.py